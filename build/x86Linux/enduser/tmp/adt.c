/* "@(#)adt.c Nov 19  1:12:04 2022" */
/* Generated by XDS Oberon-2 to ANSI C v4.20 translator */

#define X2C_int32
#define X2C_index32
#ifndef adt_H_
#include "adt.h"
#endif
#define adt_C_
#ifndef LongStrs_H_
#include "LongStrs.h"
#endif
#ifndef Printf_H_
#include "Printf.h"
#endif

extern struct X2C_MD_STR adt_desc;
X2C_INT32 adt_CurrList;
X2C_INT32 adt_MaxList;
X2C_INT32 adt_CurrTree;
X2C_INT32 adt_MaxTree;

static X2C_PROC adt_ElementDesc_proc[] = {
   (X2C_PROC)adt_Compare
};
static void * adt_ElementDesc_offs[] = {
   X2C_OFS_END
};
struct X2C_TD_STR adt_ElementDesc_desc = {
   sizeof(struct adt_ElementDesc), "ElementDesc",
   &adt_desc, 0, 1, 0,
   { &adt_ElementDesc_desc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
   adt_ElementDesc_proc, adt_ElementDesc_offs, 0, 0, 0,
                &adt_ElementDesc_desc, 0x93678150lu
};


static X2C_PROC adt_NamedElementDesc_proc[] = {
   (X2C_PROC)adt_Compare0,
   (X2C_PROC)adt_SetName
};
static void * adt_NamedElementDesc_offs[] = {
   X2C_OFS(struct adt_NamedElementDesc,name),
   X2C_OFS_END
};
struct X2C_TD_STR adt_NamedElementDesc_desc = {
   sizeof(struct adt_NamedElementDesc), "NamedElementDesc",
   &adt_desc, &adt_ListDesc_desc, 2, 1,
   { &adt_ElementDesc_desc, &adt_NamedElementDesc_desc, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0 },
   adt_NamedElementDesc_proc, adt_NamedElementDesc_offs, 0, 0, 0,
                &adt_NamedElementDesc_desc, 0x93678150lu
};


static X2C_PROC adt_StateDesc_proc[] = {
   (X2C_PROC)adt_Compare
};
static void * adt_StateDesc_offs[] = {
   X2C_OFS(struct adt_StateDesc,state),
   X2C_OFS_END
};
struct X2C_TD_STR adt_StateDesc_desc = {
   sizeof(struct adt_StateDesc), "StateDesc",
   &adt_desc, &adt_StackDesc_desc, 1, 1,
   { &adt_ElementDesc_desc, &adt_StateDesc_desc, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0 },
   adt_StateDesc_proc, adt_StateDesc_offs, 0, 0, 0, &adt_StateDesc_desc,
                0x93678150lu
};


static X2C_PROC adt_StackDesc_proc[] = {
   (X2C_PROC)adt_Compare,
   (X2C_PROC)adt_IsEmpty,
   (X2C_PROC)adt_Pop,
   (X2C_PROC)adt_Push
};
static void * adt_StackDesc_offs[] = {
   X2C_OFS(struct adt_StackDesc,down),
   X2C_OFS(struct adt_StackDesc,e),
   X2C_OFS_END
};
struct X2C_TD_STR adt_StackDesc_desc = {
   sizeof(struct adt_StackDesc), "StackDesc",
   &adt_desc, &adt_NamedElementDesc_desc, 4, 1,
   { &adt_ElementDesc_desc, &adt_StackDesc_desc, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0 },
   adt_StackDesc_proc, adt_StackDesc_offs, 0, 0, 0, &adt_StackDesc_desc,
                0x93678150lu
};


static X2C_PROC adt_TreeDesc_proc[] = {
   (X2C_PROC)adt_Compare,
   (X2C_PROC)adt_Restore,
   (X2C_PROC)adt_Backup,
   (X2C_PROC)adt_IsEmpty0,
   (X2C_PROC)adt_Delete,
   (X2C_PROC)adt_FindLast,
   (X2C_PROC)adt_FindFirst,
   (X2C_PROC)adt_FindPrev,
   (X2C_PROC)adt_FindNext,
   (X2C_PROC)adt_SetMax,
   (X2C_PROC)adt_SetMin,
   (X2C_PROC)adt_Insert,
   (X2C_PROC)adt_Find
};
static void * adt_TreeDesc_offs[] = {
   X2C_OFS(struct adt_TreeDesc,e),
   X2C_OFS(struct adt_TreeDesc,left),
   X2C_OFS(struct adt_TreeDesc,right),
   X2C_OFS(struct adt_TreeDesc,up),
   X2C_OFS(struct adt_TreeDesc,state),
   X2C_OFS_END
};
struct X2C_TD_STR adt_TreeDesc_desc = {
   sizeof(struct adt_TreeDesc), "TreeDesc",
   &adt_desc, &adt_StateDesc_desc, 13, 1,
   { &adt_ElementDesc_desc, &adt_TreeDesc_desc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0 },
   adt_TreeDesc_proc, adt_TreeDesc_offs, 0, 0, 0, &adt_TreeDesc_desc,
                0x93678150lu
};


static X2C_PROC adt_ListDesc_proc[] = {
   (X2C_PROC)adt_Compare,
   (X2C_PROC)adt_Restore0,
   (X2C_PROC)adt_Backup0,
   (X2C_PROC)adt_DeleteCurrent,
   (X2C_PROC)adt_IsEmpty1,
   (X2C_PROC)adt_FindLast0,
   (X2C_PROC)adt_FindFirst0,
   (X2C_PROC)adt_FindPrev0,
   (X2C_PROC)adt_FindNext0,
   (X2C_PROC)adt_Reset,
   (X2C_PROC)adt_FindAgain,
   (X2C_PROC)adt_Find0,
   (X2C_PROC)adt_InsertBeforeCurrent,
   (X2C_PROC)adt_InsertAfterCurrent,
   (X2C_PROC)adt_Insert0,
   (X2C_PROC)adt_Clean
};
static void * adt_ListDesc_offs[] = {
   X2C_OFS(struct adt_ListDesc,e),
   X2C_OFS(struct adt_ListDesc,prev),
   X2C_OFS(struct adt_ListDesc,next),
   X2C_OFS(struct adt_ListDesc,curr),
   X2C_OFS_END
};
struct X2C_TD_STR adt_ListDesc_desc = {
   sizeof(struct adt_ListDesc), "ListDesc",
   &adt_desc, &adt_ElementDesc_desc, 16, 1,
   { &adt_ElementDesc_desc, &adt_ListDesc_desc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0 },
   adt_ListDesc_proc, adt_ListDesc_offs, 0, 0, 0, &adt_ListDesc_desc,
                0x93678150lu
};

static adt_List ListStorage;

static adt_Stack StackStorage;

static adt_Tree TreeStorage;

static adt_List NamedElementStorage;


static void get_list(adt_List * l)
{
   if (ListStorage==0) {
      X2C_NEW(&adt_ListDesc_desc,(X2C_ADDRESS*)l,sizeof(struct adt_ListDesc),
                0);
   }
   else {
      *l = ListStorage;
      ListStorage = ListStorage->next;
   }
   adt_CurrList += (X2C_INT32)sizeof(struct adt_ListDesc);
   if (adt_MaxList<adt_CurrList) adt_MaxList = adt_CurrList;
} /* end get_list() */


static void put_list(adt_List * l)
{
   (*l)->prev = 0;
   (*l)->curr = 0;
   (*l)->e = 0;
   (*l)->next = ListStorage;
   ListStorage = *l;
   *l = 0;
   adt_CurrList -= (X2C_INT32)sizeof(struct adt_ListDesc);
} /* end put_list() */


static void get_stack(adt_Stack * s)
{
   if (StackStorage==0) {
      X2C_NEW(&adt_StackDesc_desc,(X2C_ADDRESS*)s,
                sizeof(struct adt_StackDesc),0);
   }
   else {
      *s = StackStorage;
      StackStorage = StackStorage->down;
   }
} /* end get_stack() */


static void put_stack(adt_Stack * s)
{
   (*s)->e = 0;
   (*s)->down = StackStorage;
   StackStorage = *s;
   *s = 0;
} /* end put_stack() */


static void get_tree(adt_Tree * t)
{
   if (TreeStorage==0) {
      X2C_NEW(&adt_TreeDesc_desc,(X2C_ADDRESS*)t,sizeof(struct adt_TreeDesc),
                0);
   }
   else {
      *t = TreeStorage;
      TreeStorage = TreeStorage->up;
   }
   adt_CurrTree += (X2C_INT32)sizeof(struct adt_TreeDesc);
   if (adt_MaxTree<adt_CurrTree) adt_MaxTree = adt_CurrTree;
} /* end get_tree() */


static void put_tree(adt_Tree * t)
{
   (*t)->e = 0;
   (*t)->left = 0;
   (*t)->right = 0;
   adt_Deallocate((adt_Element)(*t)->state);
   (*t)->up = TreeStorage;
   TreeStorage = *t;
   *t = 0;
   adt_CurrTree -= (X2C_INT32)sizeof(struct adt_TreeDesc);
} /* end put_tree() */


extern X2C_INT32 adt_Compare(adt_Element p, adt_Element e)
{
   return 3L;
} /* end Compare() */


extern void adt_NewStack(adt_Stack * s)
{
   get_stack(s);
   (*s)->e = 0;
   (*s)->down = 0;
} /* end NewStack() */


extern void adt_Push(adt_Stack s, adt_Element e)
{
   adt_Stack n = 0;
   if (e) {
      get_stack(&n);
      n->e = e;
      n->down = s->down;
      s->down = n;
   }
} /* end Push() */


extern void adt_Pop(adt_Stack s, adt_Element * e)
{
   adt_Stack ds = 0;
   if (s->down) {
      *e = s->down->e;
      ds = s->down;
      s->down = s->down->down;
      put_stack(&ds);
   }
   else *e = 0;
} /* end Pop() */


extern X2C_BOOLEAN adt_IsEmpty(adt_Stack s)
{
   return s->down==0;
} /* end IsEmpty() */


extern void adt_NewTree(adt_Tree * t)
{
   get_tree(t);
   (*t)->e = 0;
   (*t)->right = 0;
   (*t)->left = 0;
   (*t)->up = 0;
   (*t)->state = 0;
   (*t)->id = 0L;
   (*t)->bal = 0L;
} /* end NewTree() */


extern void adt_Find(adt_Tree t, adt_Element pattr, adt_Element * found)
{
   adt_Tree p = 0;
   *found = 0;
   if (pattr && t->up) {
      p = t->up;
      while (p) {
         switch (X2C_CALL(adt_Compare_,X2C_GET_TD(pattr),0)(pattr, p->e)) {
         case 0L:
            *found = p->e;
            return;
         case 1L:
            p = p->right;
            break;
         case 2L:
            p = p->left;
            break;
         case 3L:
            return;
         default:
            X2C_TRAP(X2C_CASE_TRAP);
         } /* end switch */
      }
   }
} /* end Find() */


static adt_Tree SimpleInsert(adt_Tree t, adt_Element e)
{
   adt_Tree h = 0;
   adt_Tree p = 0;
   X2C_BOOLEAN direction;
   if (t->up) {
      h = t->up;
      do {
         p = h;
         switch (X2C_CALL(adt_Compare_,X2C_GET_TD(e),0)(e, h->e)) {
         case 0L:
            return 0;
         case 1L:
            h = h->right;
            direction = 1;
            break;
         case 2L:
            h = h->left;
            direction = 0;
            break;
         case 3L:
            return 0;
         default:
            X2C_TRAP(X2C_CASE_TRAP);
         } /* end switch */
      } while (h);
      get_tree(&h);
      h->left = 0;
      h->right = 0;
      h->up = p;
      h->e = e;
      h->bal = 0L;
      if (direction) p->right = h;
      else p->left = h;
      return h;
   }
   else {
      get_tree(&t->up);
      t->up->e = 0;
      t->up->right = 0;
      t->up->left = 0;
      t->up->up = 0;
      t->up->id = 0L;
      t->up->bal = 0L;
      t->up->e = e;
      return t->up;
   }
   return 0;
} /* end SimpleInsert() */


extern void adt_Insert(adt_Tree t, adt_Element e)
{
   adt_Tree p2 = 0;
   adt_Tree p = 0;
   adt_Tree cur = 0;
   if (t->state==0 || X2C_CALL(adt_IsEmpty_,X2C_GET_TD(t->state),
                1)(t->state)) {
      if (e==0) return;
      cur = SimpleInsert(t, e);
      while (cur && cur!=t->up) {
         p = cur->up;
         if (p->left==cur) {
            switch (p->bal) {
            case 1L:
               p->bal = 0L;
               return;
            case 0L:
               p->bal = -1L;
               break;
            case -1L:
               if (cur->bal==-1L) {
                  p->left = cur->right;
                  if (cur->right) cur->right->up = p;
                  cur->right = p;
                  cur->up = p->up;
                  p->up = cur;
                  p->bal = 0L;
                  if (p==t->up) t->up = cur;
                  else if (cur->up->left==p) cur->up->left = cur;
                  else cur->up->right = cur;
                  p = cur;
               }
               else {
                  p2 = cur->right;
                  cur->right = p2->left;
                  if (p2->left) p2->left->up = cur;
                  p2->left = cur;
                  cur->up = p2;
                  p->left = p2->right;
                  if (p2->right) p2->right->up = p;
                  p2->right = p;
                  p2->up = p->up;
                  p->up = p2;
                  if (p2->bal==-1L) p->bal = 1L;
                  else p->bal = 0L;
                  if (p2->bal==1L) cur->bal = -1L;
                  else cur->bal = 0L;
                  if (p==t->up) t->up = p2;
                  else if (p2->up->left==p) p2->up->left = p2;
                  else p2->up->right = p2;
                  p = p2;
               }
               p->bal = 0L;
               return;
            default:
               X2C_TRAP(X2C_CASE_TRAP);
            } /* end switch */
         }
         else {
            switch (p->bal) {
            case -1L:
               p->bal = 0L;
               return;
            case 0L:
               p->bal = 1L;
               break;
            case 1L:
               if (cur->bal==1L) {
                  p->right = cur->left;
                  if (cur->left) cur->left->up = p;
                  cur->left = p;
                  cur->up = p->up;
                  p->up = cur;
                  p->bal = 0L;
                  if (p==t->up) t->up = cur;
                  else if (cur->up->left==p) cur->up->left = cur;
                  else cur->up->right = cur;
                  p = cur;
               }
               else {
                  p2 = cur->left;
                  cur->left = p2->right;
                  if (p2->right) p2->right->up = cur;
                  p2->right = cur;
                  cur->up = p2;
                  p->right = p2->left;
                  if (p2->left) p2->left->up = p;
                  p2->left = p;
                  p2->up = p->up;
                  p->up = p2;
                  if (p2->bal==1L) p->bal = -1L;
                  else p->bal = 0L;
                  if (p2->bal==-1L) cur->bal = 1L;
                  else {
                     cur->bal = 0L;
                  }
                  if (p==t->up) t->up = p2;
                  else if (p2->up->left==p) p2->up->left = p2;
                  else p2->up->right = p2;
                  p = p2;
               }
               p->bal = 0L;
               return;
            default:
               X2C_TRAP(X2C_CASE_TRAP);
            } /* end switch */
         }
         cur = cur->up;
      }
   }
   else {
      Printf_printf("Error has happend during Tree.Insert action", 44ul, 0,
                0ul);
   }
} /* end Insert() */


extern void adt_SetMin(adt_Tree t)
{
   if (t->up==0) return;
   t->up->up = t->up;
   while (t->up->up->left) t->up->up = t->up->up->left;
} /* end SetMin() */


extern void adt_SetMax(adt_Tree t)
{
   if (t->up==0) return;
   t->up->up = t->up;
   while (t->up->up->right) t->up->up = t->up->up->right;
} /* end SetMax() */


extern void adt_FindNext(adt_Tree t, adt_Element * found)
{
   adt_Tree p = 0;
   *found = 0;
   if (t->up && t->up->up) {
      *found = t->up->up->e;
      if (t->up->up->right) {
         t->up->up = t->up->up->right;
         while (t->up->up->left) t->up->up = t->up->up->left;
      }
      else {
         p = t->up->up;
         t->up->up = 0;
         while (p->up && p->up->right==p) p = p->up;
         if (p!=t) t->up->up = p->up;
         else t->up->up = 0;
      }
   }
} /* end FindNext() */


extern void adt_FindPrev(adt_Tree t, adt_Element * found)
{
   adt_Tree p = 0;
   *found = 0;
   if (t->up && t->up->up) {
      *found = t->up->up->e;
      if (t->up->up->left) {
         t->up->up = t->up->up->left;
         while (t->up->up->right) t->up->up = t->up->up->right;
      }
      else {
         p = t->up->up;
         t->up->up = 0;
         while (p->up && p->up->left==p) p = p->up;
         if (p!=t->up) t->up->up = p->up;
         else t->up->up = 0;
      }
   }
} /* end FindPrev() */


extern void adt_FindFirst(adt_Tree t, adt_Element * found)
{
   X2C_CALL(adt_SetMin_,X2C_GET_TD(t),10)(t);
   X2C_CALL(adt_FindNext_,X2C_GET_TD(t),8)(t, found);
} /* end FindFirst() */


extern void adt_FindLast(adt_Tree t, adt_Element * found)
{
   X2C_CALL(adt_SetMax_,X2C_GET_TD(t),9)(t);
   X2C_CALL(adt_FindPrev_,X2C_GET_TD(t),7)(t, found);
} /* end FindLast() */


static void BalanceL(adt_Tree * p, adt_Tree t, X2C_BOOLEAN * h)
{
   adt_Tree p2 = 0;
   adt_Tree p1 = 0;
   X2C_INT32 b2;
   X2C_INT32 b1;
   switch ((*p)->bal) {
   case -1L:
      (*p)->bal = 0L;
      break;
   case 0L:
      (*p)->bal = 1L;
      *h = 0;
      break;
   case 1L:
      p1 = (*p)->right;
      b1 = p1->bal;
      if (b1>=0L) {
         (*p)->right = p1->left;
         if (p1->left) p1->left->up = *p;
         p1->left = *p;
         p1->up = (*p)->up;
         (*p)->up = p1;
         if (b1==0L) {
            (*p)->bal = 1L;
            p1->bal = -1L;
            *h = 0;
         }
         else {
            (*p)->bal = 0L;
            p1->bal = 0L;
         }
         if (*p==t->up) t->up = p1;
         else if (p1->up->left==*p) p1->up->left = p1;
         else p1->up->right = p1;
         *p = p1;
      }
      else {
         p2 = p1->left;
         b2 = p2->bal;
         p1->left = p2->right;
         if (p2->right) p2->right->up = p1;
         p2->right = p1;
         p1->up = p2;
         (*p)->right = p2->left;
         if (p2->left) p2->left->up = *p;
         p2->left = *p;
         p2->up = (*p)->up;
         (*p)->up = p2;
         if (b2==1L) (*p)->bal = -1L;
         else (*p)->bal = 0L;
         if (b2==-1L) p1->bal = 1L;
         else p1->bal = 0L;
         if (*p==t->up) t->up = p2;
         else if (p2->up->left==*p) p2->up->left = p2;
         else p2->up->right = p2;
         *p = p2;
         p2->bal = 0L;
      }
      break;
   default:
      X2C_TRAP(X2C_CASE_TRAP);
   } /* end switch */
} /* end BalanceL() */


static void BalanceR(adt_Tree * p, adt_Tree t, X2C_BOOLEAN * h)
{
   adt_Tree p2 = 0;
   adt_Tree p1 = 0;
   X2C_INT32 b2;
   X2C_INT32 b1;
   switch ((*p)->bal) {
   case 1L:
      (*p)->bal = 0L;
      break;
   case 0L:
      (*p)->bal = -1L;
      *h = 0;
      break;
   case -1L:
      p1 = (*p)->left;
      b1 = p1->bal;
      if (b1<=0L) {
         (*p)->left = p1->right;
         if (p1->right) p1->right->up = *p;
         p1->right = *p;
         p1->up = (*p)->up;
         (*p)->up = p1;
         if (b1==0L) {
            (*p)->bal = -1L;
            p1->bal = 1L;
            *h = 0;
         }
         else {
            (*p)->bal = 0L;
            p1->bal = 0L;
         }
         if (*p==t->up) t->up = p1;
         else if (p1->up->left==*p) p1->up->left = p1;
         else p1->up->right = p1;
         *p = p1;
      }
      else {
         p2 = p1->right;
         b2 = p2->bal;
         p1->right = p2->left;
         if (p2->left) p2->left->up = p1;
         p2->left = p1;
         p1->up = p2;
         (*p)->left = p2->right;
         if (p2->right) p2->right->up = *p;
         p2->right = *p;
         p2->up = (*p)->up;
         (*p)->up = p2;
         if (b2==-1L) (*p)->bal = 1L;
         else (*p)->bal = 0L;
         if (b2==1L) p1->bal = -1L;
         else p1->bal = 0L;
         if (*p==t->up) t->up = p2;
         else if (p2->up->left==*p) p2->up->left = p2;
         else p2->up->right = p2;
         *p = p2;
         p2->bal = 0L;
      }
      break;
   default:
      X2C_TRAP(X2C_CASE_TRAP);
   } /* end switch */
} /* end BalanceR() */

#define adt_root 0

#define adt_right 1

#define adt_left 2


static void Del(adt_Tree t, adt_Tree * p, adt_Tree r, X2C_BOOLEAN * h)
{
   while (r->right) r = r->right;
   (*p)->e = r->e;
   if (r->up==*p) (*p)->left = r->left;
   else r->up->right = r->left;
   if (r->left) r->left->up = r->up;
   *h = 1;
   r = r->up;
   while (*h && r!=*p) {
      BalanceR(&r, t, h);
      r = r->up;
   }
} /* end Del() */


extern void adt_Delete(adt_Tree t, adt_Element e)
{
   adt_Tree p = 0;
   X2C_BOOLEAN h;
   X2C_INT32 direction;
   if (t->state==0 || X2C_CALL(adt_IsEmpty_,X2C_GET_TD(t->state),
                1)(t->state)) {
      if (e==0 || t->up==0) return;
      p = t->up;
      direction = 0L;
      for (;;) {
         if (p==0) return;
         switch (X2C_CALL(adt_Compare_,X2C_GET_TD(e),0)(e, p->e)) {
         case 0L:
            goto loop_exit;
         case 1L:
            p = p->right;
            direction = 1L;
            break;
         case 2L:
            p = p->left;
            direction = 2L;
            break;
         case 3L:
            return;
         default:
            X2C_TRAP(X2C_CASE_TRAP);
         } /* end switch */
      }
      loop_exit:;
      if (t->up->up==p) t->up->up = 0;
      if (p->right==0) {
         h = 1;
         if (p->left) p->left->up = p->up;
         switch (direction) {
         case 0L:
            t->up = p->left;
            return;
         case 1L:
            p->up->right = p->left;
            p = p->up;
            BalanceR(&p, t, &h);
            break;
         case 2L:
            p->up->left = p->left;
            p = p->up;
            BalanceL(&p, t, &h);
            break;
         default:
            X2C_TRAP(X2C_CASE_TRAP);
         } /* end switch */
      }
      else if (p->left==0) {
         h = 1;
         p->right->up = p->up;
         switch (direction) {
         case 0L:
            t->up = p->right;
            return;
         case 1L:
            p->up->right = p->right;
            p = p->up;
            BalanceR(&p, t, &h);
            break;
         case 2L:
            p->up->left = p->right;
            p = p->up;
            BalanceL(&p, t, &h);
            break;
         default:
            X2C_TRAP(X2C_CASE_TRAP);
         } /* end switch */
      }
      else {
         Del(t, &p, p->left, &h);
         if (h) BalanceL(&p, t, &h);
      }
      while (h && p!=t->up) {
         if (p->up->left==p) {
            p = p->up;
            BalanceL(&p, t, &h);
         }
         else {
            p = p->up;
            BalanceR(&p, t, &h);
         }
      }
   }
   else {
      Printf_printf("Error has happend during Tree.Delete action", 44ul, 0,
                0ul);
   }
} /* end Delete() */


extern X2C_BOOLEAN adt_IsEmpty0(adt_Tree t)
{
   return t->up==0;
} /* end IsEmpty() */


extern void adt_Backup(adt_Tree t, X2C_INT32 * id)
{
   adt_State s = 0;
   if (t->state==0) adt_NewStack(&t->state);
   X2C_NEW(&adt_StateDesc_desc,(X2C_ADDRESS*) &s,
                sizeof(struct adt_StateDesc),0);
   if (t->up) s->state = (adt_Element)t->up->up;
   else s->state = 0;
   s->id = t->id;
   X2C_CALL(adt_Push_,X2C_GET_TD(t->state),3)(t->state, (adt_Element)s);
   *id = t->id;
   ++t->id;
} /* end Backup() */


extern void adt_Restore(adt_Tree t, X2C_INT32 id)
{
   adt_Element e = 0;
   if (X2C_CALL(adt_IsEmpty_,X2C_GET_TD(t->state),1)(t->state)) return;
   X2C_CALL(adt_Pop_,X2C_GET_TD(t->state),2)(t->state, &e);
   if (((adt_State)e)->id==id) {
      if (((adt_State)e)->state) t->up->up = (adt_Tree)((adt_State)e)->state;
      else if (t->up) t->up->up = 0;
   }
   else {
      Printf_printf("Error has happend during Tree.Restore action", 45ul, 0,
                0ul);
   }
   --t->id;
} /* end Restore() */


extern void adt_NewList(adt_List * l)
{
   get_list(l);
   (*l)->e = 0;
   (*l)->prev = *l;
   (*l)->next = *l;
   (*l)->curr = 0;
} /* end NewList() */


extern void adt_Clean(adt_List l)
{
   if (l->next!=l) {
      l->next->prev = l->prev;
      adt_Deallocate((adt_Element)l->next);
      l->prev = l;
      l->next = l;
   }
   l->curr = 0;
} /* end Clean() */


extern void adt_Insert0(adt_List l, adt_Element e)
{
   adt_List n = 0;
   if (e) {
      get_list(&n);
      l->prev->next = n;
      n->prev = l->prev;
      l->prev = n;
      n->next = l;
      n->e = e;
   }
} /* end Insert() */


extern void adt_InsertAfterCurrent(adt_List l, adt_Element e)
{
   adt_List n = 0;
   if (e) {
      get_list(&n);
      n->next = l->curr->next;
      n->prev = l->curr;
      l->curr->next = n;
      n->next->prev = n;
      n->e = e;
   }
} /* end InsertAfterCurrent() */


extern void adt_InsertBeforeCurrent(adt_List l, adt_Element e)
{
   adt_List n = 0;
   if (e) {
      get_list(&n);
      n->next = l->curr;
      n->prev = l->curr->prev;
      l->curr->prev = n;
      n->prev->next = n;
      n->e = e;
   }
} /* end InsertBeforeCurrent() */


extern void adt_Find0(adt_List l, adt_Element pattr, adt_Element * found)
{
   adt_List p = 0;
   *found = 0;
   if (pattr) {
      p = l->next;
      while (p!=l && X2C_CALL(adt_Compare_,X2C_GET_TD(pattr),0)(pattr,
                p->e)) p = p->next;
      if (p!=l) {
         *found = p->e;
         l->curr = p;
      }
   }
} /* end Find() */


extern void adt_FindAgain(adt_List l, adt_Element * found)
{
   adt_List p = 0;
   adt_Element pattr = 0;
   p = l->curr->next;
   pattr = l->curr->e;
   while (p!=l && X2C_CALL(adt_Compare_,X2C_GET_TD(pattr),0)(pattr, p->e)) {
      p = p->next;
   }
   if (p==l) *found = 0;
   else *found = p->e;
} /* end FindAgain() */


extern void adt_Reset(adt_List l)
{
   l->curr = l;
} /* end Reset() */


extern void adt_FindNext0(adt_List l, adt_Element * found)
{
   if (l->curr && l->curr!=l->prev) {
      l->curr = l->curr->next;
      *found = l->curr->e;
   }
   else {
      X2C_CALL(adt_Reset_,X2C_GET_TD(l),9)(l);
      *found = 0;
   }
} /* end FindNext() */


extern void adt_FindPrev0(adt_List l, adt_Element * found)
{
   if (l->curr && l->curr!=l->next) {
      l->curr = l->curr->prev;
      *found = l->curr->e;
   }
   else {
      X2C_CALL(adt_Reset_,X2C_GET_TD(l),9)(l);
      *found = 0;
   }
} /* end FindPrev() */


extern void adt_FindFirst0(adt_List l, adt_Element * found)
{
   X2C_CALL(adt_Reset_,X2C_GET_TD(l),9)(l);
   X2C_CALL(adt_FindNext_0,X2C_GET_TD(l),8)(l, found);
} /* end FindFirst() */


extern void adt_FindLast0(adt_List l, adt_Element * found)
{
   X2C_CALL(adt_Reset_,X2C_GET_TD(l),9)(l);
   X2C_CALL(adt_FindPrev_0,X2C_GET_TD(l),7)(l, found);
} /* end FindLast() */


extern X2C_BOOLEAN adt_IsEmpty1(adt_List l)
{
   return l->next==l;
} /* end IsEmpty() */


extern void adt_DeleteCurrent(adt_List l)
{
   if (l->curr && l->curr!=l) {
      l->curr->next->prev = l->curr->prev;
      l->curr->prev->next = l->curr->next;
      put_list(&l->curr);
   }
} /* end DeleteCurrent() */


extern void adt_Backup0(adt_List l, X2C_INT32 * id)
{
   adt_List ll = 0;
   if (l->curr==0) *id = -1L;
   else {
      *id = 0L;
      ll = l;
      while (ll->next!=l && ll!=l->curr) {
         ++*id;
         ll = ll->next;
      }
   }
} /* end Backup() */


extern void adt_Restore0(adt_List l, X2C_INT32 id)
{
   if (id>=0L) {
      l->curr = l;
      while (id>0L) {
         l->curr = l->curr->next;
         --id;
      }
   }
   else l->curr = 0;
} /* end Restore() */


extern void adt_NewNamedElement(adt_NamedElement * ne, X2C_CHAR name[],
                X2C_CARD32 name_len)
{
   adt_Element e = 0;
   if (X2C_CALL(adt_IsEmpty_1,X2C_GET_TD(NamedElementStorage),
                4)(NamedElementStorage)) {
      X2C_NEW(&adt_NamedElementDesc_desc,(X2C_ADDRESS*)ne,
                sizeof(struct adt_NamedElementDesc),0);
   }
   else {
      X2C_CALL(adt_FindFirst_0,X2C_GET_TD(NamedElementStorage),
                6)(NamedElementStorage, &e);
      X2C_CALL(adt_DeleteCurrent_,X2C_GET_TD(NamedElementStorage),
                3)(NamedElementStorage);
      *ne = (adt_NamedElement)e;
   }
   LongStrs_Assign(name, name_len, &(*ne)->name);
} /* end NewNamedElement() */


extern void adt_SetName(adt_NamedElement ne, X2C_CHAR name[],
                X2C_CARD32 name_len)
{
   LongStrs_Assign(name, name_len, &ne->name);
} /* end SetName() */


extern X2C_INT32 adt_Compare0(adt_NamedElement p, adt_Element e)
{
   LongStrs_String anonym = 0;
   LongStrs_String anonym0 = 0;
   LongStrs_String anonym1 = 0;
   LongStrs_String anonym2 = 0;
   if (X2C_GET_TD(e)->base[1]==&adt_NamedElementDesc_desc) {
      if (anonym = p->name,(anonym0 = ((adt_NamedElement)e)->name,
                X2C_STRCMP(anonym->Adr,anonym->Len0,anonym0->Adr,
                anonym0->Len0)==0)) return 0L;
      else if (anonym1 = p->name,(anonym2 = ((adt_NamedElement)e)->name,
                X2C_STRCMP(anonym1->Adr,anonym1->Len0,anonym2->Adr,
                anonym2->Len0)>0)) return 1L;
      else return 2L;
   }
   else return 3L;
   return 0;
} /* end Compare() */


extern void adt_Deallocate(adt_Element e)
{
   adt_List l = 0;
   adt_Stack s = 0;
   adt_Tree t = 0;
   if (e==0) return;
   if (X2C_GET_TD(e)->base[1]==&adt_ListDesc_desc) {
      ((adt_List)e)->prev->next = ListStorage;
      l = (adt_List)e;
      while (l!=ListStorage) {
         l->prev = 0;
         l->curr = 0;
         l->e = 0;
         l = l->next;
         adt_CurrList -= (X2C_INT32)sizeof(struct adt_ListDesc);
      }
      ListStorage = (adt_List)e;
   }
   else if (X2C_GET_TD(e)->base[1]==&adt_StackDesc_desc) {
      s = (adt_Stack)e;
      while (s->down) {
         s->e = 0;
         s = s->down;
      }
      s->e = 0;
      s->down = StackStorage;
      StackStorage = (adt_Stack)e;
   }
   else if (X2C_GET_TD(e)->base[1]==&adt_TreeDesc_desc) {
      if (((adt_Tree)e)->up) {
         t = ((adt_Tree)e)->up;
         for (;;) {
            if (t->left) t = t->left;
            else if (t->right) t = t->right;
            else {
               if (t==((adt_Tree)e)->up) {
                  put_tree(&((adt_Tree)e)->up);
                  break;
               }
               if (t==t->up->left) {
                  t = t->up;
                  put_tree(&t->left);
               }
               else {
                  t = t->up;
                  put_tree(&t->right);
               }
            }
         }
      }
      t = (adt_Tree)e;
      put_tree(&t);
   }
   else if (X2C_GET_TD(e)->base[1]==&adt_NamedElementDesc_desc) {
      X2C_CALL(adt_Insert_0,X2C_GET_TD(NamedElementStorage),
                14)(NamedElementStorage, (adt_Element)e);
   }
} /* end Deallocate() */


static void * adt_offs[] = {
   &ListStorage,
   &StackStorage,
   &TreeStorage,
   &NamedElementStorage,
   X2C_OFS_END
};
static X2C_PROC adt_cmds[] = { 0 };
static X2C_CHAR * adt_cnms[] = { 0 };
struct X2C_MD_STR adt_desc = {
  0, 0, "adt",adt_offs,adt_cmds,adt_cnms,&adt_TreeDesc_desc
};

extern void adt_BEGIN(void)
{
   static int adt_init = 0;
   if (adt_init) return;
   adt_init = 1;
   if (sizeof(struct adt_ElementDesc)!=4) X2C_ASSERT(0);
   Printf_BEGIN();
   LongStrs_BEGIN();
   X2C_MODULE(&adt_desc);
   adt_NewList(&NamedElementStorage);
   adt_CurrList = 0L;
   adt_MaxList = 0L;
   adt_CurrTree = 0L;
   adt_MaxTree = 0L;
}


/* XDS v2.60: Copyright (c) 1999-2011 Excelsior, LLC. All Rights Reserved. */
/* "@(#)Semaphores.c Nov  7 22:55:49 2022" */
/* Generated by XDS Modula-2 to ANSI C v4.20 translator */

#define X2C_int32
#define X2C_index32
#ifndef Semaphores_H_
#include "Semaphores.h"
#endif
#define Semaphores_C_
#ifndef EXCEPTIONS_H_
#include "EXCEPTIONS.h"
#endif
#ifndef Storage_H_
#include "Storage.h"
#endif
#ifndef Processes_H_
#include "Processes.h"
#endif

#define Semaphores_magic_s 0x856F 

#define Semaphores_magic_i 0x1094 

static EXCEPTIONS_ExceptionSource source;

struct ItemRec;

typedef struct ItemRec * Item;

struct SemRec;


struct SemRec {
   X2C_CARD32 magic;
   X2C_CARD32 cnt;
   Item lst;
};


struct ItemRec {
   X2C_CARD32 magic;
   Processes_ProcessId prs;
   Item fwd;
   Item bck;
};


static void Tie(Item * list, Item i)
{
   if (*list==0) {
      *list = i;
      i->fwd = i;
      i->bck = i;
   }
   else {
      i->fwd = *list;
      i->bck = (*list)->bck;
      i->fwd->bck = i;
      i->bck->fwd = i;
   }
} /* end Tie() */


static void UnTie(Item * list, Item i)
{
   if (i->fwd==i) *list = 0;
   else {
      if (*list==i) *list = i->fwd;
      i->fwd->bck = i->bck;
      i->bck->fwd = i->fwd;
      i->fwd = i;
      i->bck = i;
   }
} /* end UnTie() */


extern void Semaphores_Create(Semaphores_SEMAPHORE * s, X2C_CARD32 i)
{
   Storage_ALLOCATE((X2C_ADDRESS*)s, sizeof(struct SemRec));
   if ((struct SemRec *)*s==0) {
      EXCEPTIONS_RAISE(source, 0UL, "Semphores.Create: no memory for semaphor\
e", 42ul);
   }
   ((struct SemRec *)*s)->magic = 34159UL;
   ((struct SemRec *)*s)->cnt = i;
   ((struct SemRec *)*s)->lst = 0;
} /* end Create() */


extern void Semaphores_Destroy(Semaphores_SEMAPHORE * s)
{
   Item i;
   X2C_PROTECTION anonym;
   X2C_PROTECT(&anonym,1);
   if ((struct SemRec *)*s==0 || ((struct SemRec *)*s)->magic!=34159UL) {
      EXCEPTIONS_RAISE(source, 1UL, "Semphores.Destroy: invalid argument",
                36ul);
   }
   while (((struct SemRec *)*s)->lst) {
      i = ((struct SemRec *)*s)->lst;
      UnTie(&((struct SemRec *)*s)->lst, i);
      i->magic = 0UL;
      Processes_Activate(i->prs);
   }
   ((struct SemRec *)*s)->magic = 0UL;
   Storage_DEALLOCATE((X2C_ADDRESS*)s, sizeof(struct SemRec));
   X2C_PROTECT(&anonym,anonym);
} /* end Destroy() */


extern void Semaphores_Claim(Semaphores_SEMAPHORE s)
{
   struct ItemRec i;
   X2C_PROTECTION anonym;
   X2C_PROTECT(&anonym,1);
   if ((struct SemRec *)s==0 || ((struct SemRec *)s)->magic!=34159UL) {
      EXCEPTIONS_RAISE(source, 2UL, "Semphores.Claim: invalid argument",
                34ul);
   }
   if (((struct SemRec *)s)->cnt>0UL) {
      --((struct SemRec *)s)->cnt;
      goto label;
   }
   i.magic = 4244UL;
   i.prs = Processes_Me();
   Tie(&((struct SemRec *)s)->lst, &i);
   Processes_SuspendMe();
   label:;
   X2C_PROTECT(&anonym,anonym);
} /* end Claim() */


extern void Semaphores_Release(Semaphores_SEMAPHORE s)
{
   Item i;
   X2C_PROTECTION anonym;
   X2C_PROTECT(&anonym,1);
   if ((struct SemRec *)s==0 || ((struct SemRec *)s)->magic!=34159UL) {
      EXCEPTIONS_RAISE(source, 3UL, "Semphores.Release: invalid argument",
                36ul);
   }
   if (((struct SemRec *)s)->lst==0) {
      ++((struct SemRec *)s)->cnt;
      goto label;
   }
   i = ((struct SemRec *)s)->lst;
   UnTie(&((struct SemRec *)s)->lst, i);
   i->magic = 0UL;
   Processes_Activate(i->prs);
   label:;
   X2C_PROTECT(&anonym,anonym);
} /* end Release() */


extern X2C_BOOLEAN Semaphores_CondClaim(Semaphores_SEMAPHORE s)
{
   X2C_PROTECTION anonym;
   X2C_BOOLEAN Semaphores_CondClaim_ret;
   X2C_PROTECT(&anonym,1);
   if ((struct SemRec *)s==0 || ((struct SemRec *)s)->magic!=34159UL) {
      EXCEPTIONS_RAISE(source, 4UL, "Semphores.CondClaim: invalid argument",
                38ul);
   }
   if (((struct SemRec *)s)->cnt>0UL) {
      --((struct SemRec *)s)->cnt;
      Semaphores_CondClaim_ret = 1;
      goto label;
   }
   Semaphores_CondClaim_ret = 0;
   label:;
   X2C_PROTECT(&anonym,anonym);
   return Semaphores_CondClaim_ret;
} /* end CondClaim() */


extern X2C_BOOLEAN Semaphores_IsSemaphoreExceptio(void)
{
   return EXCEPTIONS_IsCurrentSource(source);
} /* end IsSemaphoreException() */


extern void Semaphores_BEGIN(void)
{
   static int Semaphores_init = 0;
   if (Semaphores_init) return;
   Semaphores_init = 1;
   Processes_BEGIN();
   Storage_BEGIN();
   EXCEPTIONS_BEGIN();
   EXCEPTIONS_AllocateSource(&source);
}


/* XDS v2.60: Copyright (c) 1999-2011 Excelsior, LLC. All Rights Reserved. */
/* "@(#)Str.c Nov 19  1:11:54 2022" */
/* Generated by XDS Modula-2 to ANSI C v4.20 translator */

#define X2C_int32
#define X2C_index32
#ifndef Str_H_
#include "Str.h"
#endif
#define Str_C_
#ifndef Strings_H_
#include "Strings.h"
#endif
#ifndef LongStr_H_
#include "LongStr.h"
#endif
#ifndef ConvTypes_H_
#include "ConvTypes.h"
#endif
#ifndef LongConv_H_
#include "LongConv.h"
#endif
#ifndef WholeStr_H_
#include "WholeStr.h"
#endif



static X2C_BOOLEAN Str_inc = 1;

#define Str_ofs 32


extern void Str_Lows(X2C_CHAR S[], X2C_CARD32 S_len)
{
   X2C_CARD32 i;
   i = X2C_LENGTH(S,S_len);
   for (;;) {
      if (i==0UL) break;
      --i;
      if ((X2C_CARD8)S[i]>='A' && (X2C_CARD8)S[i]<='Z') S[i] += 32U;
   }
} /* end Lows() */

typedef X2C_INT32 T[3];

static T Str_DC = {-1L,0L,1L};

static T _cnst = {-1L,0L,1L};

extern X2C_INT32 Str_Compare(X2C_CHAR S1[], X2C_CARD32 S1_len, X2C_CHAR S2[],
                 X2C_CARD32 S2_len)
{
   return _cnst[Strings_Compare(S1, S1_len, S2, S2_len)];
} /* end Compare() */


extern void Str_Concat(X2C_CHAR R[], X2C_CARD32 R_len, X2C_CHAR S1[],
                X2C_CARD32 S1_len, X2C_CHAR S2[], X2C_CARD32 S2_len)
{
   X2C_CARD32 l2;
   X2C_CARD32 l1;
   X2C_CARD32 i;
   l1 = X2C_LENGTH(S1,S1_len);
   l2 = X2C_LENGTH(S2,S2_len);
   if (l1>R_len-1) {
      Str_Copy(R, R_len, S1, S1_len);
      return;
   }
   if (l1+l2<=R_len-1) {
      R[l1+l2] = 0;
      i = l2;
   }
   else i = ((R_len-1)-l1)+1UL;
   for (;;) {
      if (i==0UL) break;
      --i;
      R[l1+i] = S2[i];
   }
   i = 0UL;
   while (i<l1) {
      R[i] = S1[i];
      ++i;
   }
} /* end Concat() */


extern void Str_Append(X2C_CHAR R[], X2C_CARD32 R_len, X2C_CHAR S[],
                X2C_CARD32 S_len)
{
   X2C_CARD32 len;
   X2C_CARD32 i;
   X2C_CARD32 pos;
   pos = X2C_LENGTH(R,R_len);
   len = X2C_LENGTH(S,S_len);
   if (pos+len>(R_len-1)+1UL) len = ((R_len-1)+1UL)-pos;
   i = 0UL;
   while (i<len) {
      R[pos] = S[i];
      ++i;
      ++pos;
   }
   if (pos<=R_len-1) R[pos] = 0;
} /* end Append() */


extern void Str_Copy(X2C_CHAR R[], X2C_CARD32 R_len, X2C_CHAR S[],
                X2C_CARD32 S_len)
{
   X2C_CARD32 h;
   X2C_CARD32 i;
   h = S_len-1;
   if (h>R_len-1) h = R_len-1;
   i = 0UL;
   while (i<=h && S[i]) {
      R[i] = S[i];
      ++i;
   }
   if (i<=R_len-1) R[i] = 0;
} /* end Copy() */


extern void Str_Slice(X2C_CHAR R[], X2C_CARD32 R_len, X2C_CHAR S[],
                X2C_CARD32 S_len, X2C_CARD32 P, X2C_CARD32 L)
{
   X2C_CARD32 i;
   if (P>=X2C_LENGTH(S,S_len)) {
      R[0UL] = 0;
      return;
   }
   i = 0UL;
   while (((L>0UL && i<=R_len-1) && P<=S_len-1) && S[P]) {
      R[i] = S[P];
      --L;
      ++i;
      ++P;
   }
   if (i<=R_len-1) R[i] = 0;
} /* end Slice() */


extern X2C_CARD32 Str_NextPos(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR P[],
                X2C_CARD32 P_len, X2C_CARD32 Place)
{
   X2C_BOOLEAN b;
   X2C_CARD32 ps;
   Strings_FindNext(P, P_len, S, S_len, Place, &b, &ps);
   if (!b) ps = X2C_max_longcard;
   return ps;
} /* end NextPos() */


extern X2C_CARD32 Str_Pos(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR P[],
                X2C_CARD32 P_len)
{
   return Str_NextPos(S, S_len, P, P_len, 0UL);
} /* end Pos() */


extern X2C_CARD32 Str_CharPos(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR C)
{
   return Str_Pos(S, S_len, *(Strings_String1 *) &C, 1ul);
} /* end CharPos() */


extern X2C_CARD32 Str_RCharPos(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR C)
{
   X2C_BOOLEAN b;
   X2C_CARD32 l;
   X2C_CARD32 ps;
   l = X2C_LENGTH(S,S_len);
   if (l==0UL) return X2C_max_longcard;
   Strings_FindPrev(*(Strings_String1 *) &C, 1ul, S, S_len, l-1UL, &b, &ps);
   if (!b) ps = X2C_max_longcard;
   return ps;
} /* end RCharPos() */


extern void Str_Item(X2C_CHAR R[], X2C_CARD32 R_len, X2C_CHAR S[],
                X2C_CARD32 S_len, Str_CHARSET T0, X2C_CARD32 N)
{
   X2C_CARD32 LS;
   X2C_CARD32 J;
   X2C_CARD32 I;
   Str_CHARSET tmp;
   T0 = (X2C_CARD32 *)memcpy(tmp,T0,32u);
   I = 0UL;
   LS = X2C_LENGTH(S,S_len);
   for (;;) {
      while (I<LS && X2C_INL((X2C_INT32)(X2C_CARD8)S[I],256,T0)) ++I;
      if (N==0UL || I==LS) break;
      --N;
      while (I<LS && !X2C_INL((X2C_INT32)(X2C_CARD8)S[I],256,T0)) ++I;
   }
   J = I;
   while (J<LS && !X2C_INL((X2C_INT32)(X2C_CARD8)S[J],256,T0)) ++J;
   Str_Slice(R, R_len, S, S_len, I, J-I);
} /* end Item() */

static Str_CHARSET _cnst0 = {0x00000000UL,0x00000000UL,0x00000000UL,
                0x00000000UL,0x00000000UL,0x00000000UL,0x00000000UL,
                0x00000000UL};

extern void Str_ItemS(X2C_CHAR R[], X2C_CARD32 R_len, X2C_CHAR S[],
                X2C_CARD32 S_len, X2C_CHAR T0[], X2C_CARD32 T_len,
                X2C_CARD32 N)
{
   Str_CHARSET Set;
   X2C_CARD32 i;
   memcpy(Set,_cnst0,32u);
   i = 0UL;
   while (i<=T_len-1 && T0[i]) {
      X2C_INCL(Set,(X2C_CARD8)T0[i],256);
      ++i;
   }
   Str_Item(R, R_len, S, S_len, Set, N);
} /* end ItemS() */


extern void Str_Prepend(X2C_CHAR S1[], X2C_CARD32 S1_len, X2C_CHAR S2[],
                X2C_CARD32 S2_len)
{
   X2C_CARD32 n;
   X2C_CARD32 i;
   X2C_CARD32 rlen;
   X2C_CARD32 tlen;
   X2C_CARD32 slen;
   X2C_CARD32 dlen;
   slen = X2C_LENGTH(S2,S2_len);
   if (slen==0UL) return;
   dlen = X2C_LENGTH(S1,S1_len);
   tlen = (S1_len-1)+1UL;
   if (slen>tlen) slen = tlen;
   if (slen==0UL) return;
   rlen = dlen;
   n = tlen-slen;
   if (rlen>n) rlen = n;
   if (slen+rlen<tlen) S1[slen+rlen] = 0;
   i = rlen;
   n = i+slen;
   while (rlen>0UL) {
      --n;
      --i;
      S1[n] = S1[i];
      --rlen;
   }
   i = 0UL;
   n = 0UL;
   while (slen>0UL) {
      S1[n] = S2[i];
      ++n;
      ++i;
      --slen;
   }
} /* end Prepend() */


extern void Str_Insert(X2C_CHAR R[], X2C_CARD32 R_len, X2C_CHAR S[],
                X2C_CARD32 S_len, X2C_CARD32 P)
{
   X2C_CARD32 n;
   X2C_CARD32 i;
   X2C_CARD32 rlen;
   X2C_CARD32 tlen;
   X2C_CARD32 slen;
   X2C_CARD32 dlen;
   slen = X2C_LENGTH(S,S_len);
   if (slen==0UL) return;
   dlen = X2C_LENGTH(R,R_len);
   if (P>dlen) P = dlen;
   tlen = (R_len-1)+1UL;
   if (slen>tlen-P) slen = tlen-P;
   if (slen==0UL) return;
   rlen = dlen-P;
   n = tlen-(P+slen);
   if (rlen>n) rlen = n;
   if (P+slen+rlen<tlen) R[P+slen+rlen] = 0;
   i = P+rlen;
   n = i+slen;
   while (rlen>0UL) {
      --n;
      --i;
      R[n] = R[i];
      --rlen;
   }
   i = 0UL;
   n = P;
   while (slen>0UL) {
      R[n] = S[i];
      ++n;
      ++i;
      --slen;
   }
} /* end Insert() */


extern void Str_Subst(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR Target[],
                X2C_CARD32 Target_len, X2C_CHAR New[], X2C_CARD32 New_len)
{
   X2C_BOOLEAN b;
   X2C_CARD32 ps;
   Strings_FindNext(Target, Target_len, S, S_len, 0UL, &b, &ps);
   if (b) {
      Strings_Delete(S, S_len, ps, X2C_LENGTH(Target,Target_len));
      Str_Insert(S, S_len, New, New_len, ps);
   }
} /* end Subst() */


extern X2C_BOOLEAN Str_StrToC(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR D[],
                X2C_CARD32 D_len)
{
   D[0UL] = 0;
   if (D_len-1>=X2C_LENGTH(S,S_len)) {
      Str_Insert(D, D_len, S, S_len, 0UL);
      return 1;
   }
   else return 0;
   return 0;
} /* end StrToC() */


extern X2C_BOOLEAN Str_StrToPas(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR D[],
                 X2C_CARD32 D_len)
{
   X2C_CARD32 i;
   X2C_CARD32 l;
   l = X2C_LENGTH(S,S_len);
   if (D_len-1>=l && l<=255UL) {
      for (i = l; i>=1UL; i--) {
         D[i] = S[i-1UL];
      } /* end for */
      D[0UL] = (X2C_CHAR)l;
      return 1;
   }
   else {
      D[0UL] = 0;
      return 0;
   }
   return 0;
} /* end StrToPas() */


extern X2C_LONGREAL Str_StrToReal(X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_BOOLEAN * OK)
{
   X2C_CARD8 res;
   X2C_LONGREAL r;
   LongStr_StrToReal(S, S_len, &r, &res);
   *OK = res==ConvTypes_strAllRight;
   return r;
} /* end StrToReal() */


extern void Str_FixRealToStr(X2C_LONGREAL V, X2C_CARD32 Precision,
                X2C_CHAR S[], X2C_CARD32 S_len, X2C_BOOLEAN * OK)
{
   X2C_INT32 places;
   if (Precision==0UL) places = -1L;
   else places = (X2C_INT32)Precision;
   LongStr_RealToFixed(V, places, S, S_len);
   *OK = LongConv_LengthFixedReal(V, places)<=(S_len-1)+1UL;
   if (!*OK) X2C_COPY("?",2ul,S,S_len);
} /* end FixRealToStr() */


extern void Str_RealToStr(X2C_LONGREAL V, X2C_CARD32 Precision,
                X2C_BOOLEAN Eng, X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_BOOLEAN * OK)
{
   X2C_CARD32 pos;
   X2C_CARD32 digits;
   X2C_BOOLEAN inspoint;
   X2C_BOOLEAN insspace;
   X2C_BOOLEAN appzexp;
   if (Precision==0UL) Precision = 1UL;
   else if (Precision>17UL) Precision = 17UL;
   if (Eng) {
      LongStr_RealToEng(V, Precision, S, S_len);
      *OK = LongConv_LengthEngReal(V,
                (X2C_CARD32)(X2C_INT32)Precision)<=(S_len-1)+1UL;
   }
   else {
      LongStr_RealToFloat(V, Precision, S, S_len);
      *OK = LongConv_LengthFloatReal(V,
                (X2C_CARD32)(X2C_INT32)Precision)<=(S_len-1)+1UL;
   }
   if (*OK) {
      pos = 0UL;
      inspoint = 1;
      insspace = V>=0.0;
      for (;;) {
         ++pos;
         if (S[pos]==0 || pos==S_len-1) {
            appzexp = 1;
            break;
         }
         if (inspoint && S[pos]=='.') inspoint = 0;
         if (S[pos]=='E') {
            appzexp = 0;
            break;
         }
      }
      digits = (pos-(X2C_CARD32)!insspace)-(X2C_CARD32)!inspoint;
      *OK = X2C_LENGTH(S,S_len)+(Precision-digits)+(X2C_CARD32)inspoint+(X2C_CARD32)insspace+(X2C_CARD32)appzexp*3UL<=(S_len-1)+1UL;
      if (*OK) {
         while (digits<Precision) {
            Str_Insert(S, S_len, "0", 2ul, pos);
            ++digits;
         }
         if (inspoint) Str_Insert(S, S_len, ".", 2ul, pos);
         if (insspace) Str_Insert(S, S_len, " ", 2ul, 0UL);
         if (appzexp) Str_Append(S, S_len, "E+0", 4ul);
      }
   }
} /* end RealToStr() */

#define Str_Digits "0123456789ABCDEF"


static void TruncBase(X2C_CARD32 * Base)
{
   if (*Base<2UL) *Base = 2UL;
   else if (*Base>16UL) *Base = 16UL;
} /* end TruncBase() */


extern void Str_CardToStr(X2C_CARD32 V, X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_CARD32 Base, X2C_BOOLEAN * OK)
{
   X2C_CARD32 i;
   X2C_CARD32 l;
   X2C_CHAR temp;
   TruncBase(&Base);
   l = S_len-1;
   i = 0UL;
   *OK = 1;
   for (;;) {
      if (i>l) {
         *OK = 0;
         break;
      }
      S[i] = "0123456789ABCDEF"[V%Base];
      ++i;
      V = V/Base;
      if (V==0UL) break;
   }
   if (i<=l) S[i] = 0;
   l = 0UL;
   while (l<i) {
      --i;
      temp = S[l];
      S[l] = S[i];
      S[i] = temp;
      ++l;
   }
} /* end CardToStr() */

#define Str_OVR 1


extern void Str_IntToStr(X2C_INT32 V, X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_CARD32 Base, X2C_BOOLEAN * OK)
{
   if (V==X2C_min_longint) Str_CardToStr(0x080000000UL, S, S_len, Base, OK);
   else Str_CardToStr((X2C_CARD32)labs(V), S, S_len, Base, OK);
   if (V<0L) {
      if ((S_len-1)+1UL==X2C_LENGTH(S,S_len)) *OK = 0;
      Str_Prepend(S, S_len, "-", 2ul);
   }
} /* end IntToStr() */

typedef X2C_CARD8 ATC[23];

static ATC Str_ConvDig = {0U,1U,2U,3U,4U,5U,6U,7U,8U,9U,33U,33U,33U,33U,33U,
                33U,33U,10U,11U,12U,13U,14U,15U};

static ATC _cnst1 = {0U,1U,2U,3U,4U,5U,6U,7U,8U,9U,33U,33U,33U,33U,33U,33U,
                33U,10U,11U,12U,13U,14U,15U};

static X2C_CARD32 ComStrTo(const X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_CARD32 Base, X2C_BOOLEAN * OK)
{
   X2C_CARD32 l;
   X2C_CARD32 i;
   X2C_CARD32 sum;
   X2C_CHAR c;
   X2C_CARD8 x;
   TruncBase(&Base);
   *OK = 0;
   i = 0UL;
   sum = 0UL;
   if (S[0UL]=='-' || S[0UL]=='+') i = 1UL;
   l = X2C_LENGTH(S,S_len);
   if (l==i) return 0UL;
   while (i<l) {
      c = S[i];
      if ((X2C_CARD8)c<'0' || (X2C_CARD8)c>'F') return sum;
      x = _cnst1[(X2C_CARD8)c-'0'];
      if ((X2C_CARD32)x>Base-1UL || sum>(X2C_max_longcard-(X2C_CARD32)x)
                /Base) return sum;
      sum = sum*Base+(X2C_CARD32)x;
      ++i;
   }
   *OK = 1;
   return sum;
} /* end ComStrTo() */


extern X2C_INT32 Str_StrToInt(X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_CARD32 Base, X2C_BOOLEAN * OK)
{
   X2C_CARD32 t;
   t = ComStrTo(S, S_len, Base, OK);
   if (t>2147483647UL) *OK = 0;
   if (S[0UL]=='-') return -(X2C_INT32)t;
   else return (X2C_INT32)t;
   return 0;
} /* end StrToInt() */


extern X2C_CARD32 Str_StrToCard(X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_CARD32 Base, X2C_BOOLEAN * OK)
{
   X2C_CARD32 t;
   t = ComStrTo(S, S_len, Base, OK);
   if (S[0UL]=='-') *OK = 0;
   return t;
} /* end StrToCard() */

static X2C_BOOLEAN Rmatch0(X2C_CHAR [], X2C_CARD32, X2C_CARD32, X2C_CHAR [],
                X2C_CARD32, X2C_CARD32, X2C_CARD32, X2C_CARD32);


static X2C_BOOLEAN Rmatch0(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CARD32 Sl,
                X2C_CHAR P[], X2C_CARD32 P_len, X2C_CARD32 Pl, X2C_CARD32 si,
                 X2C_CARD32 pi)
{
   while (pi<Pl) {
      if (P[pi]=='*') {
         while (si<=Sl) {
            if (Rmatch0(S, S_len, Sl, P, P_len, Pl, si, pi+1UL)) return 1;
            ++si;
         }
         return 0;
      }
      if (si==Sl) return 0;
      if (P[pi]=='?') {
      }
      else if (X2C_CAP(S[si])!=X2C_CAP(P[pi])) return 0;
      ++pi;
      ++si;
   }
   return si==Sl;
} /* end Rmatch() */


extern X2C_BOOLEAN Str_Match(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR P[],
                X2C_CARD32 P_len)
{
   X2C_CARD32 Pl;
   X2C_CARD32 Sl;
   Sl = X2C_LENGTH(S,S_len);
   Pl = X2C_LENGTH(P,P_len);
   if (Pl==0UL) return Sl==0UL;
   return Rmatch0(S, S_len, Sl, P, P_len, Pl, 0UL, 0UL);
} /* end Match() */


extern X2C_BOOLEAN Str_Same(X2C_CHAR Source[], X2C_CARD32 Source_len,
                X2C_CHAR Pattern[], X2C_CARD32 Pattern_len)
{
   X2C_CARD32 i;
   X2C_BOOLEAN Str_Same_ret;
   X2C_PCOPY((void **)&Source,Source_len);
   X2C_PCOPY((void **)&Pattern,Pattern_len);
   i = 0UL;
   for (;;) {
      if (Source[i]!=Pattern[i]) {
         Str_Same_ret = 0;
         goto label;
      }
      if (Source[i]==0) {
         Str_Same_ret = 1;
         goto label;
      }
      ++i;
      if (i>Source_len-1) {
         Str_Same_ret = i>Pattern_len-1 || Pattern[i]==0;
         goto label;
      }
      if (i>Pattern_len-1) {
         Str_Same_ret = Source[i]==0;
         goto label;
      }
   }
   label:;
   X2C_PFREE(Source);
   X2C_PFREE(Pattern);
   return Str_Same_ret;
} /* end Same() */


extern X2C_CARD32 Str_Count(X2C_CHAR S[], X2C_CARD32 S_len, X2C_CHAR C)
{
   X2C_CARD32 c0;
   X2C_CARD32 i;
   X2C_CARD32 Str_Count_ret;
   X2C_PCOPY((void **)&S,S_len);
   i = 0UL;
   c0 = 0UL;
   while (i<=S_len-1 && S[i]) {
      if (S[i]==C) ++c0;
      ++i;
   }
   Str_Count_ret = c0;
   X2C_PFREE(S);
   return Str_Count_ret;
} /* end Count() */


static void SetPL(struct Str_PosLen PL[], X2C_CARD32 PL_len, X2C_CARD32 i,
                X2C_CARD32 p, X2C_CARD32 l)
{
   if (i<=PL_len-1) {
      PL[i].Len = l;
      PL[i].Pos = p;
   }
} /* end SetPL() */

static X2C_BOOLEAN Rmatch(X2C_CHAR [], X2C_CARD32, struct Str_PosLen [],
                X2C_CARD32, X2C_CARD32, X2C_CHAR [], X2C_CARD32, X2C_CARD32,
                X2C_CARD32, X2C_CARD32, X2C_CARD32);


static X2C_BOOLEAN Rmatch(X2C_CHAR S[], X2C_CARD32 S_len,
                struct Str_PosLen PL[], X2C_CARD32 PL_len, X2C_CARD32 Sl,
                X2C_CHAR P[], X2C_CARD32 P_len, X2C_CARD32 Pl0,
                X2C_CARD32 si, X2C_CARD32 pi, X2C_CARD32 iPL)
{
   X2C_CARD32 i;
   X2C_CARD32 tmp;
   while (pi<Pl0) {
      if (P[pi]=='*') {
         tmp = Sl;
         i = si;
         if (i<=tmp) for (;; i++) {
            SetPL(PL, PL_len, iPL, si, i-si);
            if (Rmatch(S, S_len, PL, PL_len, Sl, P, P_len, Pl0, i, pi+1UL,
                iPL+1UL)) return 1;
            if (i==tmp) break;
         } /* end for */
         return 0;
      }
      if (si==Sl) return 0;
      if (P[pi]=='?') {
         SetPL(PL, PL_len, iPL, si, 1UL);
         ++iPL;
      }
      else if (X2C_CAP(S[si])!=X2C_CAP(P[pi])) return 0;
      ++pi;
      ++si;
   }
   return 1;
} /* end Rmatch() */


extern X2C_BOOLEAN Str_FindSubStr(X2C_CHAR S[], X2C_CARD32 S_len,
                X2C_CHAR P[], X2C_CARD32 P_len, struct Str_PosLen PL[],
                X2C_CARD32 PL_len)
{
   X2C_CARD32 Pl0;
   X2C_CARD32 Sl;
   X2C_CARD32 i;
   X2C_CARD32 tmp;
   Sl = X2C_LENGTH(S,S_len);
   Pl0 = X2C_LENGTH(P,P_len);
   if (Pl0==0UL) return 1;
   tmp = Sl;
   i = 0UL;
   if (i<=tmp) for (;; i++) {
      if (Rmatch(S, S_len, PL, PL_len, Sl, P, P_len, Pl0, i, 0UL, 0UL)) {
         return 1;
      }
      if (i==tmp) break;
   } /* end for */
   return 0;
} /* end FindSubStr() */


extern void Str_BEGIN(void)
{
   static int Str_init = 0;
   if (Str_init) return;
   Str_init = 1;
   if (sizeof(Str_CHARSET)!=32) X2C_ASSERT(0);
   if (sizeof(ATC)!=23) X2C_ASSERT(0);
   ConvTypes_BEGIN();
   WholeStr_BEGIN();
   LongConv_BEGIN();
   LongStr_BEGIN();
   Strings_BEGIN();
}


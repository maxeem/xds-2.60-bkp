/* XDS v2.60: Copyright (c) 1999-2011 Excelsior, LLC. All Rights Reserved. */
/* "@(#)IOLink.c Nov  7 22:55:49 2022" */
/* Generated by XDS Modula-2 to ANSI C v4.20 translator */

#define X2C_int32
#define X2C_index32
#ifndef IOLink_H_
#include "IOLink.h"
#endif
#define IOLink_C_
#ifndef IOChan_H_
#include "IOChan.h"
#endif
#ifndef IOConsts_H_
#include "IOConsts.h"
#endif
#ifndef ChanConsts_H_
#include "ChanConsts.h"
#endif
#ifndef Strings_H_
#include "Strings.h"
#endif
#ifndef Storage_H_
#include "Storage.h"
#endif
#ifndef EXCEPTIONS_H_
#include "EXCEPTIONS.h"
#endif



static EXCEPTIONS_ExceptionSource source;

struct _0;


struct _0 {
   X2C_INT32 dummy0;
};

static struct IOLink_DeviceTable inv;


static void raise0(X2C_CARD8 e, const X2C_CHAR name0[], X2C_CARD32 name_len)
{
   X2C_CHAR s[129];
   switch ((unsigned)e) {
   case IOChan_wrongDevice:
      strncpy(s,"IOException.wrongDevice",129u);
      break;
   case IOChan_notAvailable:
      strncpy(s,"IOException.notAvailable",129u);
      break;
   case IOChan_skipAtEnd:
      strncpy(s,"IOException.skipAtEnd",129u);
      break;
   case IOChan_softDeviceError:
      strncpy(s,"IOException.softDeviceError",129u);
      break;
   case IOChan_hardDeviceError:
      strncpy(s,"IOException.hardDeviceError",129u);
      break;
   case IOChan_textParseError:
      strncpy(s,"IOException.textParseError",129u);
      break;
   case IOChan_notAChannel:
      strncpy(s,"IOException.notAChannel",129u);
      break;
   default:
      X2C_TRAP(X2C_CASE_TRAP);
   } /* end switch */
   if (name0[0UL]) {
      Strings_Append(" ", 2ul, s, 129ul);
      Strings_Append(name0, name_len, s, 129ul);
   }
   EXCEPTIONS_RAISE(source, (X2C_CARD32)e, s, 129ul);
} /* end raise() */


extern void IOLink_AllocateDeviceId(IOLink_DeviceId * did)
{
   Storage_ALLOCATE((X2C_ADDRESS*)did, sizeof(struct _0));
} /* end AllocateDeviceId() */


extern void IOLink_MakeChan(IOLink_DeviceId did, IOChan_ChanId * cid)
{
   IOLink_DeviceTablePtr x;
   Storage_ALLOCATE((X2C_ADDRESS*) &x, sizeof(struct IOLink_DeviceTable));
   if (x==0) *cid = IOChan_InvalidChan();
   else {
      *x = inv;
      x->did = did;
      *cid = (IOChan_ChanId)x;
      x->cid = *cid;
   }
} /* end MakeChan() */


extern void IOLink_UnMakeChan(IOLink_DeviceId did, IOChan_ChanId * cid)
{
   IOLink_DeviceTablePtr x;
   x = (IOLink_DeviceTablePtr)*cid;
   if (x==0 || (struct _0 *)did!=(struct _0 *)x->did) {
      raise0(IOChan_wrongDevice, "IOLink.UnMakeChan", 18ul);
      return;
   }
   Storage_DEALLOCATE((X2C_ADDRESS*) &x, sizeof(struct IOLink_DeviceTable));
   *cid = IOChan_InvalidChan();
} /* end UnMakeChan() */


extern IOLink_DeviceTablePtr IOLink_DeviceTablePtrValue(IOChan_ChanId cid,
                IOLink_DeviceId did, IOLink_DevExceptionRange x,
                X2C_CHAR s[], X2C_CARD32 s_len)
{
   IOLink_DeviceTablePtr dt;
   IOLink_DeviceTablePtr IOLink_DeviceTablePtrValue_ret;
   X2C_PCOPY((void **)&s,s_len);
   dt = (IOLink_DeviceTablePtr)cid;
   if (dt==0 || (struct _0 *)did!=(struct _0 *)dt->did) {
      raise0(IOChan_wrongDevice, "IOLink.DeviceTablePtrValue", 27ul);
      IOLink_DeviceTablePtrValue_ret = 0;
      goto label;
   }
   IOLink_DeviceTablePtrValue_ret = dt;
   label:;
   X2C_PFREE(s);
   return IOLink_DeviceTablePtrValue_ret;
} /* end DeviceTablePtrValue() */


extern X2C_BOOLEAN IOLink_IsDevice(IOChan_ChanId cid, IOLink_DeviceId did)
{
   IOLink_DeviceTablePtr x;
   x = (IOLink_DeviceTablePtr)cid;
   return x && (struct _0 *)did==(struct _0 *)x->did;
} /* end IsDevice() */


extern void IOLink_RAISEdevException(IOChan_ChanId cid, IOLink_DeviceId did,
                IOLink_DevExceptionRange e, X2C_CHAR s[], X2C_CARD32 s_len)
{
   IOLink_DeviceTablePtr x;
   X2C_PCOPY((void **)&s,s_len);
   x = (IOLink_DeviceTablePtr)cid;
   if (x==0 || (struct _0 *)did!=(struct _0 *)x->did) {
      raise0(IOChan_wrongDevice, "IOLink.RAISEdevException", 25ul);
      goto label;
   }
   raise0(e, s, s_len);
   label:;
   X2C_PFREE(s);
} /* end RAISEdevException() */


extern X2C_CARD8 IOLink_IOException(void)
{
   if (EXCEPTIONS_IsCurrentSource(source)) {
      return (X2C_CARD8)EXCEPTIONS_CurrentNumber(source);
   }
   else X2C_ABORT();
   return 0;
} /* end IOException() */


extern X2C_BOOLEAN IOLink_IsIOException(void)
{
   return EXCEPTIONS_IsCurrentSource(source);
} /* end IsIOException() */

static void look(IOLink_DeviceTablePtr, X2C_CHAR *, X2C_CARD8 *);


static void look(IOLink_DeviceTablePtr x, X2C_CHAR * c, X2C_CARD8 * r)
{
   raise0(IOChan_notAvailable, "Look", 5ul);
} /* end look() */

static void skip(IOLink_DeviceTablePtr);


static void skip(IOLink_DeviceTablePtr x)
{
   raise0(IOChan_notAvailable, "Skip", 5ul);
} /* end skip() */

static void read0(IOLink_DeviceTablePtr, X2C_ADDRESS, X2C_CARD32,
                X2C_CARD32 *);


static void read0(IOLink_DeviceTablePtr x, X2C_ADDRESS a, X2C_CARD32 max0,
                X2C_CARD32 * n)
{
   raise0(IOChan_notAvailable, "Read", 5ul);
} /* end read() */

static void write0(IOLink_DeviceTablePtr, X2C_ADDRESS, X2C_CARD32);


static void write0(IOLink_DeviceTablePtr x, X2C_ADDRESS a, X2C_CARD32 max0)
{
   raise0(IOChan_notAvailable, "Write", 6ul);
} /* end write() */

static void name(IOLink_DeviceTablePtr, X2C_CHAR [], X2C_CARD32);


static void name(IOLink_DeviceTablePtr x, X2C_CHAR s[], X2C_CARD32 s_len)
{
   s[0UL] = 0;
} /* end name() */

static void dummy(IOLink_DeviceTablePtr);


static void dummy(IOLink_DeviceTablePtr x)
{
} /* end dummy() */


extern void IOLink_BEGIN(void)
{
   static int IOLink_init = 0;
   if (IOLink_init) return;
   IOLink_init = 1;
   EXCEPTIONS_BEGIN();
   Storage_BEGIN();
   Strings_BEGIN();
   IOChan_BEGIN();
   IOConsts_BEGIN();
   ChanConsts_BEGIN();
   { /* with */
      struct IOLink_DeviceTable * anonym = &inv;
      anonym->cd = 0;
      Storage_ALLOCATE((X2C_ADDRESS*) &anonym->did, sizeof(struct _0));
      anonym->cid = 0;
      anonym->result = IOConsts_notKnown;
      anonym->errNum = 0L;
      anonym->flags = 0U;
      anonym->doLook = look;
      anonym->doSkip = skip;
      anonym->doSkipLook = look;
      anonym->doTextRead = read0;
      anonym->doTextWrite = write0;
      anonym->doLnWrite = skip;
      anonym->doRawRead = read0;
      anonym->doRawWrite = write0;
      anonym->doGetName = (IOLink_GetNameProc)name;
      anonym->doReset = dummy;
      anonym->doFlush = dummy;
      anonym->doFree = dummy;
   }
   EXCEPTIONS_AllocateSource(&source);
}

